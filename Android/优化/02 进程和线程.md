# 进程和线程
 当某个应用组件启动且该应用没有运行其他任何组件时，Android系统会使用单个执行线程为应用启动新的Linux进程。默认情况下，同一应用的所以组件在相同的进程和线程（主线程）中运行。如果某个组件启动时，该应用已经存在进程，则该组件会在此进程内启动并使用相同的执行线程。但是，你可以配置应用中其他组件在单独的进程中运行，并为任何进程创建额外的线程。

# 进程
 默认情况下，同一应用的所有组件均在相同的进程中运行，且大多数应用都不会改变这一点。但是如果你需要控制某个组件所属的进程，则可在清单文件中执行次操作。

 各类组件元素的清单文件条目<activity>,<service>,<receiver>和<provider>都支持`android:process`属性，此属性可以指定该组件在哪个进程运行。使用此属性你可以使每个组件在各自的进程中运行，或者使一些组件共享一个进程，而不与其他组件共享。此外还可以使不同应用的组件在相同的进程中运行，但前提是这些应用共享相同的Linux用户ID并使用相同的证书进行签名。

 此外，`<applicationk>`元素还支持`android:process`属性，以设置适用于所有组件的默认值。

 如果内存不足，而其他为用户提供更紧急服务的进程又需要内存时，Android可能会决定在某一时刻关闭某一进程。在被终止进程中运行的应用组件也会随之销毁。当这些组件需要再次运行时，系统将为他们重启进程。

 决定终止哪个进程时，Android系统将权衡他们对用户的相对重要程度。例如：对于托管可见Acitivity的进程而言，更有可能关闭托管屏幕上不再可见的Activity的进程。因此是否终止某个进程的决定取决于该进程中所运行组件的状态。下面说明决定终止进程所用的规则。

# 进程生命周期
 Android系统将尽量长时间地保存应用进程，但为了新建进程或运行更重要的进程，最终需要移除旧进程来回收内存。为了确定保留或终止哪些进程，系统会根据进程中正在运行的组件以及这些组件的状态，将每个进程放入“重要性层次结构”中。必要时，系统会首先消除重要性最低的进程，然后是重要性略高的进程，以此类推，以回收系统资源。

 重要性层次结构一共有五级。按重要性由高到底：

1. 前台进程
 用户当前操作所必需的进程。如果一个进程满足一下任一条件，即视为前台进程：
	- 托管用户正在交互的Activity（已经调用Activity的onResume()方法）
	- 托管某个Service，此Service绑定到用户正在交互的Activity
	- 托管正在“前台”运行的Service（服务已调用startForeground()）
	- 托管正在执行一个生命周期回调的Service（onCreate、onStart、onDestroy）
	- 托管正在执行onReceive方法的BroadcastReceiver

	通常，在任意给定时间前台进程都为数不多。只有在内存不足以支持他们同时继续运行这一万不得已的情况下，系统才会终止他们。此时，设备往往已经达到内存分页状态，因此需要终止一些前台进程来确保用户界面正常响应。

2. 可见进程
 没有任何前台组件，但仍会影响用户在屏幕上所见内容的进程。满足以下任一条件，即为可见进程： 

	- 托管不在前台，但仍对用户可见的Activity（已调用onPause()方法）。
	- 托管绑定到可见Activity的Service。
 	可见进程被视为极其重要的进程，除非为了维持所有前台进程同时运行而必须终止，否则系统不会终止这些进程。

3. 服务进程
 正在运行已使用startService()方法启动的服务且不属于上述两个更高级别进程的进程。尽管服务进程与用户所见内容没有直接关联，但是他们通常在执行一些用户关系的操作（播放或下载）。因此，除非内存不足以维持所有前台进程和可见进程同时运行，否则系统会让服务保持运行状态。

4. 后台进程
 包含对用户不可见的Activity的进程（已调用onStop()方法）。这些进程对用户体验没有直接影响，系统可能随时终止他们，以回收内存供前台进程，可见进程或服务进程使用。通常会有很多后台进程在运行，因此他们会保存在LRU列表中，以确保包含用户最近查看的Activity进程最后一个被终止。如果某个Activity正确实现了声明周期方法，并保存了当前状态，则终止其进程不会对用户体验产生明显影响，因为当用户导航回该Activity时，Activity会恢复其所有可见状态。

5. 空进程
 不含有任何活动应用组件的进程。保留这种进程的唯一目的是用作缓存，以缩短下次在其中运行组件所需的启动时间。为使总体系统资源在进程缓存和底层内核缓存之间保持平衡，系统往往会终止这些进程。

 根据进程中当前活动组件的重要程度，Android会将进程评定为他可能达到的最高级别。

 此外，一个进程的级别可能会因为其他进程对他的依赖而有所提高，即服务于另一个进程的进程，其级别永远不会低于其所服务的进程。

 由于运行服务的进程，其级别高于托管后台Activity的进程，因此启动长时间运行操作的Activity最好为该操作启动服务，而不是简单地创建工作线程，当操作有可能比Activity更加持久时更要如此。使用服务可以保证，无论Activity发生什么情况，该操作至少具备“服务进程”优先级。同理广播接收器也应使用服务，而不是简单地放入线程中。

# 线程
 应用启动线程时， 系统会为应用创建一个名为“主线程”的执行线程。此线程非常重要，因为它负责将事件分派给相应的用户界面部件，包括绘图事件。此外他也是应用与Android UI工具包组件进行交互的线程。主线程也称为UI线程

 系统不会为每个组件创建单独的线程。运行于同一进程的所有组件均在UI线程中实例化，并且对每个组件的系统调用均由该线程进行分派。因此响应系统回调的方法（如用户操作的onKeyDown()或生命周期方法）始终在进程的UI线程中。

 例如，当用户触摸屏幕上的按钮时，应用UI线程将触摸事件分派给按钮，而按钮反过来又设置其按下状态，并将失效请求发布到事件队列中。UI线程从队列中取消该请求并通知按钮应该重绘自身。

 在应用执行繁重的任务以响应用户交互时，除非正确实现应用，否则这种单线程模式可能会导致性能低下。如果UI执行耗时很长的操作将会阻塞整个UI，导致无法分配任何事件（触摸，绘图等）。从用户角度来讲，应用显示为挂起，如果UI线程阻塞超过几秒钟（目前五秒），用户就会看到ANR对话框，甚至会退出并卸载应用。

 此外，Android UI工具包并非线程安全。因此不得通过工作线程操作UI。

 至此，Android单线程模式必须遵守两条守则:

1. 不要阻塞UI线程
2. 不要在UI线程之外访问Android UI工具包

# 工作线程
 根据上述单线程模式，要抱着应用UI的响应能力，关键是不能阻塞UI线程。如果操作不能很快完成，则应该让他们在单独的线程中运行。

 同时，如果在非UI线程中修改UI，有可能导致出现不明确、不可预见的行为，跟踪起来困难又费时。

 Android提供了几种途径从其他线程访问UI线程：
- Activity.runOnUiThread(Runnable)
- View.post(Runnable)
- View.postDelayed(Runnable, long)

 随着操作的日趋复杂，这种方法也会变得复杂并难以维护。可以考虑在工作线程中使用Handler处理来自UI线程的消息。也可以扩展AsyncTask类。

# 使用AsyncTask
 使用时必须实现AsyncTask的子类，并实现doInBackground()方法。

- 可以使用泛型指定参数类型、进度值和任务最终值
- 方法 doInBackground() 会在工作线程上自动执行
- onPreExecute()、onPostExecute() 和 onProgressUpdate() 均在 UI 线程中调用
- doInBackground() 返回的值将发送到 onPostExecute()
- 您可以随时在 doInBackground() 中调用publishProgress()，以在 UI 线程中执行 onProgressUpdate()
- 您可以随时取消任何线程中的任务

 注意：使用工作线程时可能会遇到另一个问题，即：运行时变更（如用户更改了屏幕方向）导致Activity意外重启，这可能会销毁工作线程。

# 线程安全方法
 某些情况，方法可能会从多个线程调用，因此编写这些方法时必须确保其满足线程安全的要求。

 这一点主要适用于可以远程调用的方法，如绑定服务。如果对IBinder中所实现方法的调用源自运行IBinder的同一进程，则该方法在调用方的线程中执行。如果调用源自其他进程，则该方法将从线程池选择的某个线程中执行（而不是在进程的UI线程中执行），线程池由系统在与IBinder相同的进程中维护。例如：即使服务的onBind()方法将从服务进程的UI线程调用，在onBind()返回的对象中实现的方法（例如：实现RPC方法的子类）仍会从线程池中的线程调用。由于一个服务可以有多个客户端，因此可能会有多个池线程在同一时间使用同一IBinder方法。因此IBinder方法必须实现为线程安全方法。

 同样，内容提供程序也可以接收来自其他进程的数据请求。尽管ContentResolver和ContentProvider类隐藏了如何管理进程间通信的细节，但响应这些请求的ContentProvider方法（query(), insert(), delete(), update, getType()方法）将从内容提供程序所在进程的线程池中调用，而不是从进程的UI线程调用。由于这些方法可能会同时从任意数量的线程调用，因此他们也必须是线程安全的。

# 进程间通信
 Android利用远程进程调用（RPC）提供了一种进程间通信（IPC）机制，通过这种机制，由Activity或其他应用组件调用的方法将（在其他进程中）远程执行，而所有结果将返回给调用方。这就要求把方法调用及其数据分解至操作系统可以识别的程度，并将他们从本地进程和地址空间传输至远程进程和地址空间，然后在远程进程中重新组装并执行该调用。然后返回值将沿相反方向传输回来。Android提供了执行这些IPC事物所需的全部代码，因此您只需集中精力定义和实现RPC编程接口即可。

 要执行IPC，必须使用bindService()将应用绑定到服务上。