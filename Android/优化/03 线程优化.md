# 线程优化
 在Android上熟练使用线程可以帮助你提高应用程序的性能这里讨论使用线程的几个方面：使用UI或主线程；应用程序声明周期与线程优先级之间的关系；以及该平台提供的帮助管理线程复杂性的方法。在这些页面的每一个页面中，描述了潜在的陷阱和避免他们的策略。

# Main Thread
 当用户启动您的应用程序时，Android会创建一个新的Linux进程以及一个执行线程。这个主线程也称作UI线程，负责屏幕上发生的所以事情。了解他们的工作方式可以帮助您设计应用程序，以使主线程获得最佳性能。

## 内核 
 主线程的设计非常简单：它唯一的工作就是从线程安全的工作队列中取出并执行工作块，直到应用程序终止。该框架从各种地方生成了这些工作的一部分。这些地方包括与生命周期相关的回调，用户事件，或来自其他应用程序和进程的事件。另外，应用程序可以自己明确地排队，而不使用框架。

 您的应用程序执行的几乎任何代码块都与事件回调有关，例如输入，布局填充或绘制。当某些事件触发事件时，事件发生的线程将事件推出自身，并进入主线程的消息队列。主线程会为事件提供服务。

 当动画或屏幕更新发生时，系统会每16ms左右执行一个工作块（负责绘制屏幕），以便以每秒60帧的速度顺利进行渲染。要使系统达到此目标，UI/View层次结构必须在主线程上进行更新。但是当主线程的消息传递队列包含的任务太多或太长时，主线程无法完成足够快的更新时，应用程序应将此工作移至工作线程。如果主线程无法在16ms内完成执行工作块。则用户可能会观察到拖拉，滞后或对输入的UI响应不足。如果主线程阻塞大约五秒钟，系统将显示应用程序无响应（ANR）对话框，允许用户直接关闭应用。

 从主线程移动大量或长时间的任务，以免他们影响平滑的呈现和对用户输入的快速响应，这是你在应用中采用线程的最大原因。

# 线程和UI对象引用
 在设计上，Android View对象不是线程安全的。应用被希望在主线程上创建，使用和销毁UI对象。如果您尝试修改甚至引用主线程以外的线程中的UI对象，则结果可能是异常、无声失败、崩溃或其他错误行为。

## 显式引用
 非主线程上的许多任务都有更新UI对象的最终目标。但是如果其中一个线程访问视图层次结果中的某个对象，则可能导致应用程序不稳定。

 例如，考虑一个应用程序，该应用程序在工作线程上保存对UI对象的直接引用。 工作线程上的对象可能包含对视图的引用; 但在工作完成之前，视图将从视图层次结构中删除。 当这两个动作同时发生时，引用会将View对象保存在内存中并为其设置属性。 但是，用户从不会看到此对象，并且该应用程序在引用该对象后不再删除该对象。

 另一个例子，View对象包含对拥有他们的Activity的引用。如果该Activity销毁，但仍有一个直接或间接的引用他的线程块，那么垃圾回收器在线程结束之前将不会收集该活动。

 在某些活动声明周期事件（如屏幕旋转）发生时，线程工作可能正在进行中的情况下，可能会导致出现问题。系统将无法执行垃圾收集，直到正在进行的工作完成。因此在垃圾收集发生之前，内存中可能有两个Activity对象。

 通过这些场景，我们建议你的应用程序不要在线程工作中包含对UI对象的显式引用。避免这种引用可以帮助避免这些类型的内存泄露，同时避免线程争夺。

 在所有情况下，您的应用只应该在主线程上更新UI对象。这意味着你应该指定一个策略，允许多个线程将工作流交回到主线程，主线程负责更新实际的UI对象。

## 隐式引用
 下面的代码片段中可以看到带有线程对象的常见代码设计缺陷：
```
	public class MainActivity extends Activity {
	  // …...
	  public class MyAsyncTask extends AsyncTask<Void, Void, String>   {
	    @Override protected String doInBackground(Void... params) {...}
	    @Override protected void onPostExecute(String result) {...}
	  }
	}
```
 这段代码中的缺陷是代码将线程对象MyAsyncTask声明为Activity的非静态内部类。该声明创建了对外部Activity实例的隐式引用。因此该对象包含对该Activity的引用，直到线程工作完成，导致Activity的销毁延迟。反过来，这种延迟给内存带来了更大的压力。

 直接解决这个问题的方法是将你的重载类实例定义为静态类，或者在它们自己的文件中去掉隐式引用。

另一种解决方案是将AsyncTask对象声明为静态嵌套类。 这样做可以消除隐式引用问题，因为静态嵌套类与内部类的方式不同：内部类的实例需要实例化外部类的实例，并且可以直接访问其外部方法和字段实例。 相比之下，静态嵌套类不需要引用封闭类的实例，因此它不包含对外部类成员的引用。
```
	public class MainActivity extends Activity {
	  // …...
	  static public class MyAsyncTask extends AsyncTask<Void, Void, String>   {
	    @Override protected String doInBackground(Void... params) {...}
	    @Override protected void onPostExecute(String result) {...}
	  }
	}
```

# 线程和应用及Activity声明周期
 应用程序生命周期可以影响线程在您的应用程序中的工作方式。你可能需要决定一个线程该不该在一个Activity被销毁之后继续存在。还应该知道线程优先级与活动是在前台还是后台运行之间的关系。

## 持续线程
 线程一直存在与产生他们的Activity的整个声明周期中。无论活动的创建或销毁如何，线程都可以不间断地执行。某些情况下这种持久性是需要的。

 考虑一种情况，其中一个活动产生一组线程化的工作块，然后在工作线程执行块之前被销毁。 应用程序应该如何处理正在flight的区块？

 如果代码要更新不再存在的UI，则没有继续工作的必要了。例如，从数据库加载用户信息然后展示。

 另外，工作可能有一些不完全与用户界面相关的益处。这种情况下，应该坚持这个线程。例如：数据包正在等待下载镜像将其缓存到磁盘，并更新到相关联额View。

 手动关系所以线程对象的生命周期响应可能变得非常复杂。如果没有正确管理他们，你的应用可能会出现争抢内存和性能的问题。Loaders是解决这个问题的方法之一。Loader有助于异步加载数据，同时还可以通过配置更改来保存信息。

## 线程优先级
 应用程序线程获得的优先级部分取决于应用程序的生命周期阶段。在您创建和管理应用程序中的线程时，设置其优先级是重要的，以便正确的线程在正确的时间获得正确的优先级。如果设置的太高，你的线程可能会中断UI线程和RenderThread，导致你的应用程序丢帧。如果设置的太低，可能使你的异步任务比他们需要的慢。

 每次创建线程时，都应该调用`setThreadPriority()`。系统的线程调度程序优先考虑高优先级的线程，需要平衡这些优先级与最终完成所有工作的需要。通常前台组中的线程占设备总执行时间的95%左右，而后台组大约占5%。

 系统也使用Process类为每个线程分配自己的优先级的值。

 默认情况下，系统将线程的优先级设置为与父线程相同的优先级和组成员资格。但是，您的应用可以使用setThreadPriority()明确调整线程优先级。

 Process类通过提供一组常量来帮助降低分配优先级值的复杂性，你可以使用这些常量。例如，THREAD_PRIORITY_DEFAULT表示线程的默认值。对于执行不太紧急的工作的线程，您的应用应该将优先级设置为THREAD_PRIORITY_BACKGROUND。

 您的应用可以使用THREAD_PRIORITY_LESS_FAVORABLE和THREAD_PRIORITY_MORE_FAVORABLE常量作为增量设置相对优先级。

# 线程帮助类
 该框架提供了相同的Java类和原语以促进线程化，例如Thread，Runnable和Executors类。 为了帮助减少与为Android开发线程应用程序相关的认知负载，该框架提供了一组可帮助开发的帮助类，例如AsyncTaskLoader和AsyncTask。 每个帮助类都有一组特定的性能细微差别，这使得它们对于特定的线程问题子集来说是唯一的。 对错误的情况使用错误的类可能会导致性能问题。

## AsyncTask
 对于需要将工作从主线程快速移动到工作线程的应用程序，AsyncTask类是一个简单而有用的基元。例如，输入事件可能触发需要使用加载的位图来更新UI。 AsyncTask对象可以将位图加载和解码卸载到备用线程;一旦处理完成，AsyncTask对象就可以管理接收主线程上的工作以更新UI。

 使用AsyncTask时，要记住一些重要的性能方面。首先默认情况下，应用程序将其创建的所以AsyncTask对象推送到单个线程中。因此，他们以串行方式执行，并且与主线程一样，特别长的工作包可以阻塞队列。处于这个原因，我们建议只使用AsyncTask来处理持续时间断于5ms的工作项目。

 AsyncTask对象也是隐式引用问题的最常见犯罪者。 AsyncTask对象也存在与明确引用相关的风险，但这些风险有时更容易解决。 例如，AsyncTask可能需要对UI对象的引用，以便在AsyncTask在主线程上执行回调后正确更新UI对象。 在这种情况下，您可以使用WeakReference存储对所需UI对象的引用，并在AsyncTask在主线程上运行后访问该对象。 清楚地说，将一个WeakReference引用到一个对象上并不会使该对象成为线程安全的; WeakReference仅提供了一种处理显式引用和垃圾收集问题的方法